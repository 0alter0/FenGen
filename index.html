<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FenGen</title>
  <style>
    :root{--bg:#0b1220;--card:#0f1724;--muted:#9aa4b2;--accent:#5eead4}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,#071021 0%,#071629 100%);color:#e6eef6;padding:18px}
    .app{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:20px}
    .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,.6)}
    h1{margin:0 0 8px;font-size:20px}
    .small{color:var(--muted);font-size:13px}
    .board{width:480px;height:480px;display:grid;grid-template-columns:repeat(8,1fr);border-radius:8px;overflow:hidden;border:2px solid rgba(255,255,255,.03)}
    .square{width:100%;height:100%;display:flex;align-items:center;justify-content:center;user-select:none}
    .square.light{background:linear-gradient(180deg,#f0e9d8,#e9deca)}
    .square.dark{background:linear-gradient(180deg,#b58863,#a56a3e)}
    .square img{max-width:86%;max-height:86%;pointer-events:none}
    .palette{display:grid;grid-template-columns:repeat(2,1fr);gap:6px}
    .piece-btn{background:rgba(255,255,255,.03);border-radius:8px;padding:6px;display:flex;gap:8px;align-items:center;cursor:grab}
    label,input,select,button{font:inherit}
    .controls{display:flex;flex-direction:column;gap:8px}
    .row{display:flex;gap:8px;align-items:center}
    .flex{display:flex;gap:8px}
    input[type=number]{width:66px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,.04);background:transparent;color:inherit}
    input[type=range]{width:100%}
    textarea{width:100%;height:82px;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,.04);color:inherit}
    .muted{color:var(--muted)}
    .big-btn{background:var(--accent);color:#022;border:none;padding:10px;border-radius:8px;cursor:pointer}
    .small-btn{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.04);padding:6px;border-radius:6px;cursor:pointer}
    .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
    .settings{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .footer-note{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <div class="topbar">
        <div>
          <h1>FenGen</h1>
          <div class="small">Create legal-ish chess FEN positions quickly. Default: white-perspective.</div>
        </div>
        <div class="small muted">assets path: <code id="assetsPathText">assets/PNG</code></div>
      </div>

      <div style="margin-bottom:10px">
        <div class="small">Piece palette (drag onto board). Click a piece to pick and click again on a square to place.</div>
        <div class="palette" id="palette"></div>
      </div>

      <div style="margin-top:8px" class="controls">
        <div class="row">
          <label class="small muted">Total pieces</label>
          <input id="totalPiecesRange" type="range" min="2" max="32" value="32">
          <div id="totalPiecesLabel" class="small">32</div>
        </div>

        <div>
          <div class="small muted">Per-piece maximum (set 1â€“6). These caps will be enforced during placement.</div>
          <div class="settings" id="pieceCaps"></div>
        </div>

        <div class="row">
          <label class="small muted">Side to move</label>
          <select id="sideToMove"><option value="w">White</option><option value="b">Black</option></select>
          <button id="flipBtn" class="small-btn">Flip board (perspective)</button>
        </div>

        <div class="row">
          <button id="genFen" class="big-btn">Generate FEN</button>
          <button id="clearBtn" class="small-btn">Clear board</button>
        </div>

        <textarea id="fenOut" readonly placeholder="FEN will appear here"></textarea>
        <div class="footer-note">Notes: Validator ensures common illegalities are prevented (pawns on 1st/8th rank, both kings present & not adjacent, piece counts within caps, total pieces within [2,32]). It attempts to detect basic checks but cannot guarantee full legality like en-passant rights or castling rights correctness. You can manually edit the FEN after generation.</div>
      </div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
        <div><strong>Board</strong> <span class="small muted">(click squares or drag pieces)</span></div>
        <div class="small muted">Perspective: <span id="perspectiveLabel">White</span></div>
      </div>

      <div id="boardWrap">
        <div id="board" class="board" aria-label="Chess board"></div>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <div class="small muted">Assets path</div>
        <input id="assetsPath" value="assets/PNG" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,.04);background:transparent;color:inherit">
        <button id="applyPath" class="small-btn">Apply</button>
      </div>

    </div>
  </div>

<script>


const PIECES = ['wK','wQ','wR','wB','wN','wP','bK','bQ','bR','bB','bN','bP'];
const DEFAULT_CAP = 2;
let assetsPath = 'assets/';
let board = Array.from({length:8}, ()=>Array(8).fill(null));
let pickedPiece = null;
let flipped = false;
let perPieceCap = {};
let totalPieceCap = 32;

function uid(){return Math.random().toString(36).slice(2,9)}

function makePalette(){
  const palette = document.getElementById('palette'); palette.innerHTML='';
  for(const p of PIECES){
    const btn = document.createElement('div'); btn.className='piece-btn'; btn.draggable=true; btn.dataset.piece=p;
    btn.innerHTML = `<img src="${assetsPath}/${p}.png" alt="${p}" width="36" height="36"> <div style="font-size:13px">${p}</div>`;
    btn.addEventListener('click', ()=>{ pickedPiece = p; document.querySelectorAll('.piece-btn').forEach(b=>b.style.outline=''); btn.style.outline='2px solid rgba(94,234,212,.25)'; });
    btn.addEventListener('dragstart', (e)=>{ e.dataTransfer.setData('text/plain', p); });
    palette.appendChild(btn);
  }
}

function makeCapsUI(){
  const container = document.getElementById('pieceCaps'); container.innerHTML='';
  for(const p of PIECES){
    perPieceCap[p]=DEFAULT_CAP;
    const wrap = document.createElement('div'); wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.gap='6px';
    wrap.innerHTML = `<div class="small" style="width:36px">${p}</div><input type=number min=1 max=6 value=${DEFAULT_CAP} data-piece="${p}">`;
    container.appendChild(wrap);
  }
  container.querySelectorAll('input').forEach(inp=>{
    inp.addEventListener('change', (e)=>{
      let v = parseInt(e.target.value)||1; if(v<1) v=1; if(v>6) v=6; e.target.value=v; perPieceCap[e.target.dataset.piece]=v; updateCountsAndLimits();
    });
  });
}

function createBoardUI(){
  const boardEl = document.getElementById('board'); boardEl.innerHTML='';
  const ranks = [...Array(8).keys()];
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      const sq = document.createElement('div'); sq.className='square '+(((r+f)%2) ? 'dark' : 'light');
      sq.dataset.r = r; sq.dataset.f = f;
      sq.addEventListener('click', ()=>onSquareClick(r,f));
      sq.addEventListener('dragover', (e)=>e.preventDefault());
      sq.addEventListener('drop', (e)=>{ e.preventDefault(); const p = e.dataTransfer.getData('text/plain'); placePieceAt(p,r,f); });
      boardEl.appendChild(sq);
    }
  }
  renderBoard();
}

function renderBoard(){
  const boardEl = document.getElementById('board');
  const squares = boardEl.querySelectorAll('.square');
  squares.forEach(sq=>{ sq.innerHTML=''; const r=+sq.dataset.r, f=+sq.dataset.f; const p = board[r][f]; if(p){ const img = document.createElement('img'); img.src=`${assetsPath}/${p}.png`; img.alt=p; sq.appendChild(img); }});
}

function onSquareClick(r,f){
  if(pickedPiece){ placePieceAt(pickedPiece,r,f); return; }
  board[r][f]=null; renderBoard(); updateCountsAndLimits();
}

function placePieceAt(piece,r,f){
  const rankIndex = r; // 0 is rank8, 7 is rank1
  if((piece==='wP' || piece==='bP') && (rankIndex===0 || rankIndex===7)){
    alert('Illegal: pawns cannot be placed on first (rank 1) or last (rank 8) rank.'); return;
  }
  const counts = currentCounts();
  if((counts[piece]||0) + 1 > perPieceCap[piece]){ alert(`Max ${perPieceCap[piece]} of ${piece} allowed`); return; }
  const total = Object.values(counts).reduce((a,b)=>a+b,0);
  if(total+1 > totalPieceCap){ alert('Total pieces exceed limit'); return; }
  board[r][f]=piece; renderBoard(); updateCountsAndLimits();
}

function currentCounts(){
  const c = {}; for(const p of PIECES) c[p]=0;
  for(let r=0;r<8;r++) for(let f=0;f<8;f++) if(board[r][f]) c[board[r][f]]++;
  return c;
}

function updateCountsAndLimits(){
  const counts = currentCounts();
  document.getElementById('totalPiecesLabel').textContent = Object.values(counts).reduce((a,b)=>a+b,0)+'';
}

function clearBoard(){ board = Array.from({length:8}, ()=>Array(8).fill(null)); renderBoard(); updateCountsAndLimits(); }

function coordsToAlgebraic(r,f){ const file = 'abcdefgh'[f]; const rank = 8 - r; return file+rank; }

function generateFEN(){
  const counts = currentCounts();
  const total = Object.values(counts).reduce((a,b)=>a+b,0);
  if(total < 2 || total > totalPieceCap) { alert('Total pieces must be between 2 and '+totalPieceCap); return null; }
  if(counts['wK']!==1 || counts['bK']!==1){ alert('Position must contain exactly one white king and one black king.'); return null; }
  for(let f=0;f<8;f++){ if(board[0][f]==='wP' || board[0][f]==='bP' || board[7][f]==='wP' || board[7][f]==='bP') { alert('Pawns on rank 1/8 are illegal'); return null; } }
  const wKing = findPiece('wK'); const bKing = findPiece('bK');
  if(!wKing || !bKing) return null;
  if(Math.max(Math.abs(wKing.r-bKing.r), Math.abs(wKing.f-bKing.f))<=1){ alert('Illegal: kings are adjacent.'); return null; }

  for(const p of PIECES){ if(counts[p] > perPieceCap[p]){ alert(`Too many ${p}: ${counts[p]} > ${perPieceCap[p]}`); return null; } }

  const wInCheck = isInCheck('w'); const bInCheck = isInCheck('b');
  if(wInCheck && bInCheck){ alert('Both kings are in check â€” illegal position.'); return null; }

  // Build FEN piece placement
  const fenRows = [];
  for(let r=0;r<8;r++){
    let row=''; let empty=0;
    for(let f=0;f<8;f++){
      const p = board[r][f];
      if(!p){ empty++; } else { if(empty>0){ row+=empty; empty=0; } row += pieceToFenChar(p); }
    }
    if(empty>0) row+=empty;
    fenRows.push(row);
  }
  const placement = fenRows.join('/');
  const side = document.getElementById('sideToMove').value === 'w' ? 'w' : 'b';
  const castling='-'; 
  const enpassant='-';
  const halfmove='0';
  const fullmove='1';
  const fen = `${placement} ${side} ${castling} ${enpassant} ${halfmove} ${fullmove}`;
  return fen;
}

function pieceToFenChar(p){
  const map = {wK:'K',wQ:'Q',wR:'R',wB:'B',wN:'N',wP:'P',bK:'k',bQ:'q',bR:'r',bB:'b',bN:'n',bP:'p'}; return map[p]||'?';
}

function findPiece(code){ for(let r=0;r<8;r++) for(let f=0;f<8;f++) if(board[r][f]===code) return {r,f}; return null }

function isInCheck(side){
  const king = findPiece(side==='w' ? 'wK' : 'bK'); if(!king) return false;
  const opponentPrefixes = side==='w' ? ['b'] : ['w'];
  const dirsRook = [[1,0],[-1,0],[0,1],[0,-1]];
  const dirsBishop = [[1,1],[1,-1],[-1,1],[-1,-1]];
  const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  const pawnDir = side==='w' ? -1 : 1; 
  const pr = king.r + pawnDir; for(const pf of [king.f-1, king.f+1]) if(inBounds(pr,pf) && board[pr][pf] && board[pr][pf].toLowerCase().startsWith(opponentPrefixes[0]) && board[pr][pf].endsWith('P')) return true;
  for(const m of knightMoves){ const nr=king.r+m[0], nf=king.f+m[1]; if(inBounds(nr,nf) && board[nr][nf] && board[nr][nf].endsWith('N') && board[nr][nf][0]!==kingOf(side)) return true; }
  for(const d of dirsRook){ let nr=king.r+d[0], nf=king.f+d[1]; while(inBounds(nr,nf)){ if(board[nr][nf]){ const p=board[nr][nf]; if(p.endsWith('R') || p.endsWith('Q')) return p[0]!==kingOf(side); break; } nr+=d[0]; nf+=d[1]; }}
  for(const d of dirsBishop){ let nr=king.r+d[0], nf=king.f+d[1]; while(inBounds(nr,nf)){ if(board[nr][nf]){ const p=board[nr][nf]; if(p.endsWith('B') || p.endsWith('Q')) return p[0]!==kingOf(side); break; } nr+=d[0]; nf+=d[1]; }}
  return false;
}
function kingOf(side){ return side==='w' ? 'w' : 'b'; }
function inBounds(r,f){ return r>=0 && r<8 && f>=0 && f<8 }

createBoardUI(); makePalette(); makeCapsUI(); updateCountsAndLimits();

document.getElementById('totalPiecesRange').addEventListener('input', (e)=>{ totalPieceCap = parseInt(e.target.value); document.getElementById('totalPiecesLabel').textContent = Object.values(currentCounts()).reduce((a,b)=>a+b,0) + '/' + totalPieceCap; });

document.getElementById('genFen').addEventListener('click', ()=>{
  const fen = generateFEN(); if(fen){ document.getElementById('fenOut').value = fen; }
});

document.getElementById('clearBtn').addEventListener('click', ()=>{ if(confirm('Clear board?')) clearBoard(); });

document.getElementById('applyPath').addEventListener('click', ()=>{ assetsPath = document.getElementById('assetsPath').value.trim() || 'assets/PNG'; document.getElementById('assetsPathText').textContent = assetsPath; makePalette(); renderBoard(); });

document.getElementById('flipBtn').addEventListener('click', ()=>{ flipped = !flipped; document.getElementById('perspectiveLabel').textContent = flipped ? 'Black' : 'White'; // re-render orientation by flipping board DOM
  const boardEl = document.getElementById('board'); boardEl.style.transform = flipped ? 'rotate(180deg)' : 'none';
  boardEl.querySelectorAll('img').forEach(img=> img.style.transform = flipped ? 'rotate(180deg)' : 'none');
});


window.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ pickedPiece=null; document.querySelectorAll('.piece-btn').forEach(b=>b.style.outline=''); } });

const observer = new MutationObserver(()=>{ document.getElementById('board').querySelectorAll('img').forEach(img=> img.style.transform = flipped ? 'rotate(180deg)' : 'none'); });
observer.observe(document.getElementById('board'), {childList:true, subtree:true});

</script>
</body>
</html>
